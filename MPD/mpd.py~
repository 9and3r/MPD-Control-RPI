import logging
from mpd import MPD
import requests
from fanart.music import Artist
from fanart.music import Album
import fanart
from fanart.core import Request
import os
import musicbrainz2.webservice as ws
import json
import thread
import random
import time
import math
import pygame


# Class must have this name
class MPD:

    def __init__(self,surface):
	self.setPluginVariables()
	self.surface = surface
	self.screensize = (320, 240)
    
    def setPluginVariables(self):

	self.touchList = {'PROGRESSBAR': None, 'PLAYBUTTON' : None, 'VOLUMEBAR': None, 'RANDOM' : None, 'REPEAT' : None, 'VOLUMEBUTTON' : None}
	self.lastVolume = 50

	#Load MDP server config file
	self.ip = 'localhost'
	self.port = '6600'
	self.fanarttvkey = '1df8573d7b7ba335019693c84a224588'
	os.environ.setdefault('FANART_APIKEY', self.fanarttvkey)

	self.backgroundshow = '1'
	self.covershow = '1'
        
	# Connect to MDP server
	logging.basicConfig()
	self.client = MPDClient()
	self.connected = False
	thread.start_new_thread(self.connectMDPserver,())

	#Set background colors
	self.colorR = random.randint(0, 150)
	self.colorG = random.randint(0, 150)
	self.colorB = random.randint(0, 150)
	self.R = random.randint(0, 150)
	self.G = random.randint(0, 150)
	self.B = random.randint(0, 150)
	self.colorTime = 0

	self.setNoSong()

    def connectMDPserver(self):
	# Connect to MDP server
	try:
		self.client.connect(self.ip, self.port)
		self.connected = True
	except:
		print "Could not connect to MDP server. Check configuration"
		self.connected = False
		time.sleep(10)
		self.connectMDPserver()
	self.client_info = None



    # Set No Song
    def setNoSong(self):
	self.currenttrack = None
        self.currentart = None
        self.currenttrackname = None
        self.currentartist = None
        self.currentalbum = None
	self.elapse = 0.0
	self.currenttime = 0.0
	self.background_ready = False
	self.artistId = None
	self.disc_ready = False
	self.albumId = None

    
    # Get current track information
    def getCurrentTrackInfo(self):
        self.currentSong = self.client.currentsong()
	self.currenttrack = self.currentSong['id']
        self.currentart = None
        self.currenttrackname = self.currentSong['title']
        self.currentartist = self.currentSong['artist']
        self.currentalbum = self.currentSong['album']
	self.currenttime = float(self.currentSong['time'])
	self.back_filepath = os.path.join("plugins/MPD/background", '%s%s' % (self.currentartist, '.jpg'))
	self.disc_filepath = os.path.join("plugins/MPD/disc", '%s%s' % (self.currentalbum, '.jpg'))
	self.artistId = None
	self.albumId = None

	#load images
	if self.backgroundshow == '1':
		self.loadBackground()
	if self.covershow == '1':
		self.loadDiscImage()
    
     
    def loadBackground(self):
	#see if there is a background
	#if there is not it will try to download
	try:
   		with open(self.back_filepath): pass
		self.currentart = pygame.transform.scale(pygame.image.load(self.back_filepath),(self.surface.get_width(),self.surface.get_height()))
		self.background_ready = True
	except IOError:
   		self.background_ready = False
		thread.start_new_thread(self.downloadBackground,())

    
    #find artistID in MusicBrainz
    def getArtistId(self):
	if self.artistId == None:
		q = ws.Query()

		#See if the there is more than an artist
		#If true it will use the first one
		if "," in self.currentartist:
			artistOne=self.currentartist.split(",")[0]
		else:
			artistOne=self.currentartist
		filter = ws.ArtistFilter(artistOne)
		artist=q.getArtists(filter)

		#Choose the artist with highest score
		artists=q.getArtists(filter)
		maxscore = 0
		doubt = False
		for artist in artists:
			if maxscore < artist.getScore():
				match_artist = artist.getArtist()
				maxscore = artist.getScore()
			else:
				if maxscore == artist.getScore():
					doubt = True
		if doubt:
			match_artist = self.findRealArtist(maxscore,artists).getArtist()			
		artistId = match_artist.getId()
		artistId = artistId.split("/")
		self.artistId=artistId[len(artistId)-1]

    	
    def findRealArtist(self,score,artists):
	#this takes artists who has that score
	#it will try to find the artist who has the current song
	found = False
	artist_found = None
	num = 0
	while not found and num<len(artists):
		artist = artists[num]

		if score == artist.getScore():
			if self.isRealArtist(artist.getArtist().getId()):
				found = True
				artist_found=artist
		num = num +1
	if found:
		return artist_found
	else:
		return artist

    def isRealArtist(self, idArtist):
	#looks if the artist has the curren track in MusicBrainz
	q = ws.Query()
	filter = ws.TrackFilter(self.currenttrackname,artistId=idArtist)
	tracks=q.getTracks(filter)
	if len(tracks) > 0:
		return True
	else:
		return False

    #get the albumId (ReleaseGroup ID) in MusicBrainz
    def getAlbumId(self):
	if self.albumId == None:
		q = ws.Query()

		#Filter the releases of MusicBrainz with the artistID
		filter = ws.ReleaseGroupFilter(self.currentalbum,artistId=self.artistId)
		releases=q.getReleaseGroups(filter)
		match_release = None

		#Choose the album with best match
		maxscore = 0
		for release in releases:
			if maxscore < release.getScore():
				maxscore = release.getScore()
				match_release = release.getReleaseGroup()

		#if the album was found get the id from MusiBrainz url
		if match_release != None:
			albumId = match_release.getId()
			albumId = albumId.split("/")
			self.albumId=albumId[len(albumId)-1]

    def downloadDiscImage(self):
	#Download cover from fanart.tv
	self.getArtistId()
	self.getAlbumId()
	target_album = None
	#Find album in the artist discs
	artist = Artist.get(id=self.artistId)
	for album in artist.albums:
		if album.mbid == self.albumId:
			target_album = album
	if target_album != None and len(target_album.covers)>0:
		disc_image = target_album.covers[0]
		with open(self.disc_filepath, 'wb') as fp:
				fp.write(disc_image.content())
	self.loadDiscImage()

    def loadDiscImage(self):
	#see if there is a disc cover
	#if there is not it will try to download
	try:
   		with open(self.disc_filepath): pass
		self.currentdisc = pygame.transform.scale(pygame.image.load(self.disc_filepath),(250,250))
		self.disc_ready = True
	except IOError:
   		self.disc_ready = False
		thread.start_new_thread(self.downloadDiscImage,())

    def downloadBackground(self):
	#Download background from fanart.tv
	try:
		self.getArtistId()
		#Start with fanart.tv
		artist = Artist.get(id=self.artistId)
		background = artist.backgrounds[0]
		with open(self.back_filepath, 'wb') as fp:
			fp.write(background.content())
		self.currentart = pygame.transform.scale(pygame.image.load(self.back_filepath),(self.surface.get_width(),self.surface.get_height()))
		self.loadBackground()
    	except:
		print "Error Downloading background"

    # See if the track has changed
    def hasTrackChanged(self):

	#Update the status of the client
	self.client_info = self.client.status()

	#See if it is playing

	if self.client_info['state'] == 'play':
		playing = 1
		#See if the track has changed
		if  'songid' in self.client_info:
			if self.currenttrack != self.client_info['songid']:
				self.getCurrentTrackInfo()
			self.elapse = float(self.client_info['elapsed'])
	else:
		if self.client_info['state'] == 'pause':
			playing = 0
		else:
			self.setNoSong()
			playing = -1
	return playing

    #changes the color of the background
    def dynamicBackgroundColor(self):

	if self.colorR < self.R:
		self.colorR=self.colorR+1
	if self.colorR>self.R:
		self.colorR=self.colorR-1
	if self.colorG < self.G:
		self.colorG=self.colorG+1
	if self.colorG>self.G:
		self.colorG=self.colorG-1
	if self.colorB < self.B:
		self.colorB=self.colorB+1
	if self.colorB>self.B:
		self.colorB=self.colorB-1
	#if we are in the desired color set a new target color
	if self.colorR==self.R and self.colorG==self.G and self.colorB==self.B:
		self.R = random.randint(0, 150)
		self.G = random.randint(0, 150)
		self.B = random.randint(0, 150)
	self.surface.fill([self.colorR,self.colorG,self.colorB])

    def nextTrack(self):
	self.client.next()

    def seekTrack(self, rect, mousePos):
	#Get sec to seek to
	sec = self.getPosBar(rect, mousePos, self.currenttime)
	self.client.seekcur(sec)

    def setVolume(self, rect, mousePos):
	vol = self.getPosBar(rect, mousePos, 100)
	self.client.setvol(vol)

    #Get the clicked position in the bar
    def getPosBar(self, rect, mousePos, maxValue):
	return (((mousePos[0]-rect.left)*100/rect.width) * int(maxValue)) /100

    def event(self, event):
	 if (event.type == pygame.KEYDOWN):
            if (event.key == pygame.K_RIGHT):
		self.nextTrack()

    def play(self):
	if self.connected:
		if self.hasTrackChanged()==1:
			self.client.pause()
		else:
			self.client.play()

    def mute(self):
	if self.client_info['volume']=="0":
		self.client.setvol(self.lastVolume)
	else:
		self.lastVolume = int(self.client_info['volume'])
		self.client.setvol(0)

    def changeTrack(self ,next):
	if next ==1:
		self.client.next()
	else:
		self.client.previous()

    def verticalSwipe(self, mouseDownPos, mouseUpPos):
	if(math.fabs(mouseDownPos[0]-mouseUpPos[0])<50):
		if(mouseDownPos[1]-mouseUpPos[1]>50):
			return 1
		else:
			if(mouseUpPos[1]-mouseDownPos[1]>50):
				return -1

			else:
				return 0

	else:
		return 0

    def changeRepeat(self):
	if self.client_info['repeat'] == "0":
		self.client.repeat("1")
	else:
		self.client.repeat("0")

    def changeRandom(self):
	if self.client_info['random'] == "0":
		self.client.random("1")
	else:
		self.client.random("0")		

    def mouseClick(self, mouseDownPos, mouseUpPos):
	swipe = self.verticalSwipe(mouseDownPos, mouseUpPos)
	if swipe == 0:
		for key in self.touchList:
			if key == 'PROGRESSBAR':
				if self.touchList[key].collidepoint(mouseDownPos):
					self.seekTrack(self.touchList[key], mouseDownPos)
			if key == 'VOLUMEBAR':
				if self.touchList[key].collidepoint(mouseDownPos):
					self.setVolume(self.touchList[key], mouseDownPos)
			if key == 'PLAYBUTTON':
				if self.touchList[key].collidepoint(mouseDownPos):
					self.play()
			if key == 'REPEAT':
				if self.touchList[key].collidepoint(mouseDownPos):
					self.changeRepeat()
			if key == 'RANDOM':
				if self.touchList[key].collidepoint(mouseDownPos):
					self.changeRandom()
			if key == 'VOLUMEBUTTON':
				if self.touchList[key].collidepoint(mouseDownPos):
					self.mute()
    	else:
		self.changeTrack(swipe)


    # Main function - returns screen to main script
    def showScreen(self):

	#paint background and cover
	if self.background_ready:
        	self.surface.blit(self.currentart, (0,0))
	else:
		self.dynamicBackgroundColor()
        if self.disc_ready: 
		self.surface.blit(self.currentdisc, (20,108))

        myfont = pygame.font.SysFont(None, 30)
        mybigfont = pygame.font.SysFont(None, 38)
        mysmallfont = pygame.font.SysFont(None, 24)

	#Check the connection to the MPD server
        if self.connected:
		playing = self.hasTrackChanged()
        	
        
        	# Now playing...
		if playing == 1:
        		nowtext = myfont.render("Now playing...", 1, (255,255,255))
        		self.surface.blit(nowtext, (290, 130))
                    
        	
        	# get artist name
        	artisttext = mybigfont.render(self.currentartist, 1, [255,255,255])
        	self.surface.blit(artisttext, (290,170))
                    
        	# get track name
        	tracktext = myfont.render(self.currenttrackname, 1, [255,255,255])
        	self.surface.blit(tracktext, (290,220))        

        	# get track album
        	albumtext = myfont.render(self.currentalbum, 1, [255,255,255])
        	self.surface.blit(albumtext, (290,260))   

        	# Show progress bar and time if a song is playing
		if playing==1:
        		trackposition = self.elapse / self.currenttime
			progressSurface = self.showProgress(trackposition,(150,10),(255,255,255),(0,0,144),(0,0,0))
        		self.surface.blit(progressSurface,(290,300))
			self.touchList['PROGRESSBAR'] = pygame.Rect(290,300,150,10)
                	    
        		elapsem, elapses = divmod(int(self.elapse),60)
        		elapseh, elapsem = divmod(elapsem, 60)
        		elapsestring = "%02d:%02d" % (elapsem, elapses)
        		if elapseh > 0 : elapsestring = elapsestring + "%d:" % (elapseh)
                		    
        		durationm, durations = divmod(int(self.currenttime),60)
        		durationh, durationm = divmod(durationm, 60)             
        		durationstring = "%02d:%02d" % (durationm, durations)
        		if durationh > 0 : durationstring = durationstring + "%d:" % (durationh)    
                	    
        		progressstring = "%s / %s" % (elapsestring, durationstring)
                	    
       			progresstext = myfont.render(progressstring, 1, (255,255,255))
        		self.surface.blit(progresstext, (455, 295))


			#Show Playback controls on the screen
			x = 0
			playtext = myfont.render('Pause', 1, [255,255,255])
			#Put a little bit darker to see the text in bright images
			topBack = pygame.Surface((self.surface.get_rect().width,playtext.get_rect().height),flags=pygame.SRCALPHA)
			topBack.fill([0,0,0,120])
			self.surface.blit(topBack, (0, 0))

			if self.client_info['repeat']!='1':
				repeattext = myfont.render('Repeat', 1, [255,255,255])
			else:
				repeattext = myfont.render('Repeat', 1, [30,200,40])
			x = x + playtext.get_rect().width+15
			self.surface.blit(repeattext, (x,0)) 
			self.touchList['REPEAT'] = pygame.Rect(x,0,repeattext.get_rect().width,repeattext.get_rect().height) 
			if self.client_info['random']!='1':
				randomtext = myfont.render('Random', 1, [255,255,255])
			else:
				randomtext = myfont.render('Random', 1, [30,200,40])
			x = x + repeattext.get_rect().width+15
			self.surface.blit(randomtext, (x,0))
			self.touchList['RANDOM'] = pygame.Rect(x,0,randomtext.get_rect().width,randomtext.get_rect().height)
			x = x + randomtext.get_rect().width+15

			#Show volume
			if self.client_info['volume']!='0':
				volumetext = myfont.render('Vol:', 1, [255,255,255])
			else:
				volumetext = myfont.render('Vol:', 1, [30,200,40])
			self.surface.blit(volumetext, (x,0))
			self.touchList['VOLUMEBUTTON'] = pygame.Rect(x,0,volumetext.get_rect().width,volumetext.get_rect().height)
			x = x + volumetext.get_rect().width+15
			volume = float(self.client_info['volume'])/100.0
			volumeBar = self.showProgress(volume,(150,15),(255,255,255),(0,0,144),(0,0,0))
        		self.surface.blit(volumeBar,(x,5))
			self.touchList['VOLUMEBAR'] = pygame.Rect(x,0,150,15)

		else:
			playtext = myfont.render('Play', 1, [255,255,255])
        	self.surface.blit(playtext, (0,0)) 
		self.touchList['PLAYBUTTON'] = pygame.Rect(0,0,playtext.get_rect().width,playtext.get_rect().height)


	#show to the user that the connection do not work
	else:
        	nowtext = myfont.render("Could not connect to " +self.ip+":"+self.port, 1, (255,255,255))
        	self.surface.blit(nowtext, (0, 0))
		nowtext = myfont.render("Check the configuration", 1, (255,255,255))
        	self.surface.blit(nowtext, (0, 50))
		nowtext = myfont.render("Anyway the software is trying to connect", 1, (255,255,255))
        	self.surface.blit(nowtext, (0, 100))

        # Scale our surface to the required screensize before sending back
        scaled = pygame.transform.scale(self.surface,self.screensize)
        self.screen.blit(scaled,(0,0))
            
        return self.screen
